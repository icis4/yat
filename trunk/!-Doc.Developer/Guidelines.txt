
Assemblies
----------

Sign all library/dll assemblies using the strong name tool:
1. Open the Visual Studio command prompt with administrator rights
2. Go to "C:\"
3. Enter "sn -k <FileName>.snk"
4. Move the .snk file to the "\Properties" directory of the project
5. Project Properties > Signing > Sign

Note that it is not possible to link to an .snk file. Thus, it is not possible
to create a single .snk file for collection of assemblies and than link to that
single file from the various projects.

Enforce CLS compliance
[assembly: CLSCompliant(true)]

Define CODE_ANALYSIS

Use StyleCop

Use FxCop


Comments
--------

Use special tags
\todo        :   \todo: <Description>        or   \todo (<Date> / <Author>): <Description>)
\fixme       :   \fixme: <Description>       or   \fixme (<Date> / <Author>): <Description>)
\remind      :   \remind: <Description>      or   \remind (<Date> / <Author>): <Description>)

Use special temporary tags
\TEMP
\DEBUG
\TRACE

Use <c>null</c>
Use <c>true</c>
Use <c>false</c>

Generics     : <see cref="T:Type`1"/>
Methods      : <see cref="Add()"/>           or   <see cref="Add"/>   if ambiguous


Preprocessor statements
-----------------------

Use
#if (FALSE)
to permanently disable blocks of code.
FALSE is never defined in C#, #if (FALSE) clearly states that block isn't in use.

Write
#if (FALSE)
			<Block>
#endif
at column 0 to keep code structure clear of disabled block.

Use
#if (!DEBUG)
			try
			{
#endif
to enable or disable blocks of code depending on configuration switches or write preprocessor
statements one level out of normal code structure to clearly show that these statements
		#if (!DEBUG)
			try
			{
		#endif
do not belong to the normal code. Decide on version a) or b) such that readability is optimal.


Classes
-------
Use static classes instead of Singletons


Static Classes
--------------
Use e.g. 'public static' instead of 'static public'
Use e.g. 'public static new' instead of something else


Inheritance
-----------
- Implement IEquatable
- Implement ICloneable (Problem: return type is object)
- Implement TryParse() and Parse()
- Use and TryParse() instead of Parse()

Do not use extension methods <Method> (this…) as they could lead to future incompatibilities
if the additional methods are supported by a future version of .NET with same parameters but
differing functionality.


Events
------
Use "EventArgs.Empty" instead of "new EventArgs()".
Use MKY.EventHelper.
Use MKY.Diagnostics.EventManagementHelper.Notify...() in Dispose() or ~Finalizer.

Finalization
------------
Use MKY.Diagnostics.FinalizationHelper

Disposal
--------
Use MKY.Diagnostics.DebugDisposal

Base class

		class Class : IDisposable

		#region Fields
		//==========================================================================================
		// Fields
		//==========================================================================================

		private bool isDisposed;

		#endregion

		#region Disposal
		//------------------------------------------------------------------------------------------
		// Disposal
		//------------------------------------------------------------------------------------------

		/// <summary></summary>
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary></summary>
		protected virtual void Dispose(bool disposing)
		{
			if (!IsDisposed)
			{
				// Dispose of managed resources:
				if (disposing)
				{
					if (this.FIELD != null)
						this.FIELD.Dispose();

					// In the 'normal' case, the FIELD is CLOSED/DISPOSED in METHOD().
				}

				// Dispose of unmanaged resources:
				if (this.FIELD != null)
					this.FIELD.Dispose();

				// Set state to disposed:
				this.FIELD = null;
				IsDisposed = true;
			}
		}

#if (DEBUG)

		/// <remarks>
		/// Microsoft.Design rule CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable requests
		/// "Types that declare disposable members should also implement IDisposable. If the type
		///  does not own any unmanaged resources, do not implement a finalizer on it."
		/// 
		/// Well, true for best performance on finalizing. However, it's not easy to find missing
		/// calls to <see cref="Dispose()"/>. In order to detect such missing calls, the finalizer
		/// is kept for DEBUG, indicating missing calls.
		/// 
		/// Note that it is not possible to mark a finalizer with [Conditional("DEBUG")].
		/// </remarks>
		~CLASS()
		{
			Dispose(false);

			MKY.Diagnostics.DebugDisposal.DebugNotifyFinalizerInsteadOfDispose(this);
		}

#endif // DEBUG

((		/// <summary></summary>
		public bool IsDisposed
		{
			get { return (this.isDisposed); }
))		}

		/// <summary></summary>
		protected void AssertNotDisposed()
		{
			if (IsDisposed)
				throw (new ObjectDisposedException(GetType().ToString(), "Object has already been disposed!"));
		}

		#endregion


Inherited class

		#region Disposal
		//------------------------------------------------------------------------------------------
		// Disposal
		//------------------------------------------------------------------------------------------

		protected override void Dispose(bool disposing)
		{
			// Finalize managed resources.
			   - or -
			// In any case, <CLOSE> the <ITEM>:
			
			if (disposing)
			{
				// Dispose of unmanaged resources.
				   - or -
				// In the 'normal' case, the <ITEM> is <CLOSED> in <METHOD>().
			}

			base.Dispose(disposing);
		}

		#endregion


Call AssertNotDisposed() in every non-private member.
Do not call AssertNotDisposed() in a simple get-property.

Also see "Implementing Finalize and Dispose to Clean Up Unmanaged Resources" in the MSDN.


Equality
--------
> Always implement operators ==/!= on value types
> Where needed, implement implement operators ==/!= on value types and IEquatable<T> on reference types
   > Improves performance
> See Template.cs for implementation
> Also see MKY.Test.EqualityAnalysis


Variables
---------
- Do not re-initialize fields with default value of respective type
- Always initialize local variables


Properties
----------
- Write..
	if (this.<field> != value)
	{
		this.<field> = value;
  ..instead of..
	if (value != this.<field>)
	{
		this.<field> = value;
  to improve readability and reduce the risk of copy-paste errors.


Console
-------
- Use Console.Out or Console.Error to emphasize the output stream, do not use Console itself.


Useful .NET classes
-------------------
- Console.Title/.ForegroundColor/.ResetColor
- System.Media.SystemSounds
- DefaultFontValue


Threading
---------

Threads should never be aborted. The thread that calls Abort() might block if the thread that is being aborted is in a protected region of code, such as a catch block, finally block, or constrained execution region. If the thread that calls Abort holds a lock that the aborted thread requires, a deadlock can occur.
Reference:
http://stackoverflow.com/questions/7634797/why-threadabortexception-does-not-throw-in-catch-block
http://msdn.microsoft.com/en-us/library/5b50fdsz.aspx


Windows.Forms
-------------
- 'StatusStrip' items do not show tool tip by default, 'ShowItemToolTips' must be manually set to 'True'.
- Use the 'Shown' event to initially set controls of a form:

		/// <summary>
		/// Initially set controls and validate its contents where needed.
		/// </summary>
		/// <remarks>
		/// The 'Shown' event is only raised the first time a form is displayed; subsequently
		/// minimizing, maximizing, restoring, hiding, showing, or invalidating and repainting will
		/// not raise this event again.
		/// Note that the 'Shown' event is raised after the 'Load' event and will also be raised if
		/// the application is started minimized. Also note that operations called in the 'Shown'
		/// event can depend on a properly drawn form, as the 'Paint' event of this form and its
		/// child controls has been raised before this 'Shown' event.
		/// </remarks>
		private void <Form>_Shown(object sender, EventArgs e)
		{

- Use the 'StartUp-And-Properly-Show-UserControl-Controls' pattern to initially set controls of a user control:

		/// <summary>
		/// Startup flag only used in the following event handler.
		/// </summary>
		private bool isStartingUp = true;

		/// <summary>
		/// Initially set controls and validate its contents where needed.
		/// </summary>
		/// <remarks>
		/// Use paint event to ensure that message boxes in case of errors (e.g. validation errors)
		/// are shown on top of a properly painted control or form.
		/// </remarks>
		private void <UserControl>_Paint(object sender, PaintEventArgs e)
		{
			if (this.isStartingUp)
			{
				this.isStartingUp = false;

- For more details on events of Windows.Forms, see the MKY > SequenceOfFormAndControlEvents demo project.


Known issues
------------
- Die ReadLine() Methode der .NET Komponente funktioniert nicht zuverlässig mit USB-RS232 Konvertern


Further input
-------------
- "Excel sample [.NET Framework]"
