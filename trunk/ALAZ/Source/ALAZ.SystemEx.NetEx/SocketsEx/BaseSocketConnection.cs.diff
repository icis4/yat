@@ -175,35 +175,7 @@
                 FieldInfo f = t.GetField("m_Completed", BindingFlags.Instance | BindingFlags.NonPublic);
                 f.SetValue(FReadOV, null);
 
-                // ----- \remind BEGIN -----
-
-                // 2010-05-14 / Matthias Klaey
-                // Handling System.InvalidOperationException on closing/disposing:
-                // "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance."
-                //
-                // at System.Net.Sockets.SocketAsyncEventArgs.StartConfiguring()
-                // at System.Net.Sockets.SocketAsyncEventArgs.SetBufferInternal(Byte[] buffer, Int32 offset, Int32 count)
-                // at System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(Byte[] buffer, Int32 offset, Int32 count)
-                // at ALAZ.SystemEx.NetEx.SocketsEx.BaseSocketConnection.Free(Boolean canAccessFinalizable) in C:\_Matthias\Sandboxes\YAT\Trunk\ALAZ\Source\ALAZ.SystemEx.NetEx\SocketsEx\BaseSocketConnection.cs:line 178
-                // at ALAZ.SystemEx.BaseDisposable.Dispose() in C:\_Matthias\Sandboxes\YAT\Trunk\ALAZ\Source\ALAZ.SystemEx\BaseDisposable.cs:line 108
-                // at ALAZ.SystemEx.NetEx.SocketsEx.BaseSocketConnectionHost.DisposeConnection(BaseSocketConnection connection) in C:\_Matthias\Sandboxes\YAT\Trunk\ALAZ\Source\ALAZ.SystemEx.NetEx\SocketsEx\BaseSocketConnectionHost.cs:line 1797
-                // at ALAZ.SystemEx.NetEx.SocketsEx.BaseSocketConnectionHost.BeginDisconnectCallbackAsync(Object sender, SocketAsyncEventArgs e) in C:\_Matthias\Sandboxes\YAT\Trunk\ALAZ\Source\ALAZ.SystemEx.NetEx\SocketsEx\BaseSocketConnectionHost.cs:line 1509
-                // at System.Net.Sockets.SocketAsyncEventArgs.OnCompleted(SocketAsyncEventArgs e)
-                // at System.Net.Sockets.SocketAsyncEventArgs.ExecutionCallback(Object ignored)
-                // at System.Threading.ExecutionContext.runTryCode(Object userData)
-                // at System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, Object userData)
-                // at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)
-                // at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
-                // at System.Net.Sockets.SocketAsyncEventArgs.FinishOperationSuccess(SocketError socketError, Int32 bytesTransferred, SocketFlags flags)
-                // at System.Net.Sockets.SocketAsyncEventArgs.CompletionPortCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped)
-                // at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP)
-                //
-                // Trying to fix it by uncommenting the seemingly unnecessary SetBuffer():
-
-//              FReadOV.SetBuffer(null, 0, 0);
-
-                // ----- \remind  END  -----
-
+                FReadOV.SetBuffer(null, 0, 0);
                 FReadOV.Dispose();
                 FReadOV = null;
 
@@ -311,17 +283,10 @@
                     return false;
                 }
 
-                // ----- \remind BEGIN -----
-
-                // 2011-04-25 / Matthias Klaey
-                // Work-around to the issue described in the header of AutoSocket.
-
-                //lock (FSyncActive)
-                //{
+                lock (FSyncActive)
+                {
                     return FActive;
-                //}
-
-                // ----- \remind  END  -----
+                }
             }
 
             set 
