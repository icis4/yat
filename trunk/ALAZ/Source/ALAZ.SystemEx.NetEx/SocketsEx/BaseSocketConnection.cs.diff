@@ -175,7 +175,34 @@ namespace ALAZ.SystemEx.NetEx.SocketsEx
                 FieldInfo f = t.GetField("m_Completed", BindingFlags.Instance | BindingFlags.NonPublic);
                 f.SetValue(FReadOV, null);
 
-                FReadOV.SetBuffer(null, 0, 0);
+                // ----- \remind BEGIN -----
+                // 2010-05-14 / Matthias Klaey
+                // Handling System.InvalidOperationException on closing/disposing:
+                // "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance."
+                //
+                // at System.Net.Sockets.SocketAsyncEventArgs.StartConfiguring()
+                // at System.Net.Sockets.SocketAsyncEventArgs.SetBufferInternal(Byte[] buffer, Int32 offset, Int32 count)
+                // at System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(Byte[] buffer, Int32 offset, Int32 count)
+                // at ALAZ.SystemEx.NetEx.SocketsEx.BaseSocketConnection.Free(Boolean canAccessFinalizable) in <ROOT>\ALAZ\Source\ALAZ.SystemEx.NetEx\SocketsEx\BaseSocketConnection.cs:line 178
+                // at ALAZ.SystemEx.BaseDisposable.Dispose() in <ROOT>\ALAZ\Source\ALAZ.SystemEx\BaseDisposable.cs:line 108
+                // at ALAZ.SystemEx.NetEx.SocketsEx.BaseSocketConnectionHost.DisposeConnection(BaseSocketConnection connection) in <ROOT>\ALAZ\Source\ALAZ.SystemEx.NetEx\SocketsEx\BaseSocketConnectionHost.cs:line 1797
+                // at ALAZ.SystemEx.NetEx.SocketsEx.BaseSocketConnectionHost.BeginDisconnectCallbackAsync(Object sender, SocketAsyncEventArgs e) in <ROOT>\ALAZ\Source\ALAZ.SystemEx.NetEx\SocketsEx\BaseSocketConnectionHost.cs:line 1509
+                // at System.Net.Sockets.SocketAsyncEventArgs.OnCompleted(SocketAsyncEventArgs e)
+                // at System.Net.Sockets.SocketAsyncEventArgs.ExecutionCallback(Object ignored)
+                // at System.Threading.ExecutionContext.runTryCode(Object userData)
+                // at System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, Object userData)
+                // at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)
+                // at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
+                // at System.Net.Sockets.SocketAsyncEventArgs.FinishOperationSuccess(SocketError socketError, Int32 bytesTransferred, SocketFlags flags)
+                // at System.Net.Sockets.SocketAsyncEventArgs.CompletionPortCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped)
+                // at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP)
+                //
+                // Trying to fix it by uncommenting the seemingly unnecessary SetBuffer():
+
+            ////FReadOV.SetBuffer(null, 0, 0);
+
+                // ----- \remind  END  -----
+
                 FReadOV.Dispose();
                 FReadOV = null;
 
@@ -189,7 +216,16 @@ namespace ALAZ.SystemEx.NetEx.SocketsEx
                 FieldInfo f = t.GetField("m_Completed", BindingFlags.Instance | BindingFlags.NonPublic);
                 f.SetValue(FWriteOV, null);
 
-                FWriteOV.SetBuffer(null, 0, 0);
+                // ----- \remind BEGIN -----
+                // 2015-06-01 / Matthias Klaey
+                // Handling System.InvalidOperationException on closing/disposing:
+                // "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance."
+                // Details see above. Trying to fix it by uncommenting the seemingly unnecessary SetBuffer():
+
+            ////FWriteOV.SetBuffer(null, 0, 0);
+
+                // ----- \remind  END  -----
+
                 FWriteOV.Dispose();
                 FWriteOV = null;
 
@@ -283,10 +319,17 @@ namespace ALAZ.SystemEx.NetEx.SocketsEx
                     return false;
                 }
 
-                lock (FSyncActive)
-                {
+                // ----- \remind BEGIN -----
+
+                // 2011-04-25 / Matthias Klaey
+                // Workaround to an issue described in the headers of MKY AutoSocket/TcpClient/TcpServer.
+
+//              lock (FSyncActive)
+//              {
                     return FActive;
-                }
+//              }
+
+                // ----- \remind  END  -----
             }
 
             set 
