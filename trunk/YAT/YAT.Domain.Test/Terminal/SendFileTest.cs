//==================================================================================================
// YAT - Yet Another Terminal.
// Visit YAT at https://sourceforge.net/projects/y-a-terminal/.
// Contact YAT by mailto:y-a-terminal@users.sourceforge.net.
// ------------------------------------------------------------------------------------------------
// $URL$
// $Revision$
// $Date$
// $Author$
// ------------------------------------------------------------------------------------------------
// YAT Version 2.2.0 Development
// ------------------------------------------------------------------------------------------------
// See release notes for product version details.
// See SVN change log for file revision details.
// Author(s): Matthias Klaey
// ------------------------------------------------------------------------------------------------
// Copyright © 2007-2020 Matthias Kläy.
// All rights reserved.
// ------------------------------------------------------------------------------------------------
// This source code is licensed under the GNU LGPL.
// See http://www.gnu.org/licenses/lgpl.html for license details.
//==================================================================================================

#region Using
//==================================================================================================
// Using
//==================================================================================================

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;

using MKY;
using MKY.IO.Serial.SerialPort;

using NUnit.Framework;

using YAT.Domain.Settings;

#endregion

namespace YAT.Domain.Test.Terminal
{
	/// <summary></summary>
	public static class SendFileTestTestData
	{
		#region Test Values
		//==========================================================================================
		// Test Values
		//==========================================================================================

		/// <summary></summary>
		public static IEnumerable<TerminalType> TerminalTypes
		{
			get
			{
				var l = new List<TerminalType>(2); // Preset the required capacity to improve memory management.
				l.Add(TerminalType.Text);
				l.Add(TerminalType.Binary);
				return (l);
			}
		}

		/// <summary></summary>
		public static IEnumerable<Tuple<bool, string>> SettingsFlavors
		{
			get
			{
				var l = new List<Tuple<bool, string>>(2); // Preset the required capacity to improve memory management.
				l.Add(new Tuple<bool, string>(false, "Default"));
				l.Add(new Tuple<bool, string>(true, "Modified"));
				return (l);
			}
		}

		/// <summary></summary>
		public static IEnumerable<StressFile> FileSelections
		{
			get
			{
				var l = new List<StressFile>(4); // Preset the required capacity to improve memory management.
				l.Add(StressFile.LongLine);
				l.Add(StressFile.VeryLongLine);
				l.Add(StressFile.VeryLongMultiLine);
				l.Add(StressFile.EnormousLine);
				return (l);
			}
		}

		#endregion

		#region Test Cases
		//==========================================================================================
		// Test Cases
		//==========================================================================================

		/// <remarks>
		/// Test cases are generated by code rather than using <see cref="ValuesAttribute"/> for
		/// being able to name the test cases in a human readable way.
		/// </remarks>
		private static IEnumerable<TestCaseData> Tests
		{
			get
			{
				foreach (var tt in TerminalTypes)
				{
					foreach (var flavor in SettingsFlavors)
					{
						foreach (var file in FileSelections)
						{
							var nameSuffix = string.Format(CultureInfo.CurrentCulture, "_{0}_{1}_{2}", tt, flavor.Item2, file);

							yield return (new TestCaseData(tt, flavor.Item1, file).SetName(nameSuffix));
						}
					}
				}
			}
		}

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Justification = "Emphasize variational manner of this item.")]
		public static IEnumerable TestCasesSerialPortLoopbackPairs_Text
		{
			get
			{
				foreach (var tc in Data.ToSerialPortLoopbackPairsTestCases_Text(Tests))
					yield return (tc);
			}
		}

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Selfs", Justification = "Multiple items, same as 'Pairs'.")]
		[SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Justification = "Emphasize variational manner of this item.")]
		public static IEnumerable TestCasesSerialPortLoopbackSelfs_Text
		{
			get
			{
				foreach (var tc in Data.ToSerialPortLoopbackSelfsTestCases_Text(Tests))
					yield return (tc);
			}
		}

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Justification = "Emphasize variational manner of this item.")]
		public static IEnumerable TestCasesIPSocketPairs_Text
		{
			get
			{
				foreach (var t in Tests)
				{
					var modifySettings = (bool)(t.Arguments[3]);
					if (modifySettings)
						continue; // No need to generate these settings for IP sockets (yet).

					foreach (var tc in Data.ToIPSocketPairsTestCases_Text(new TestCaseData[] { t }))
						yield return (tc);
				}
			}
		}

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Selfs", Justification = "Multiple items, same as 'Pairs'.")]
		[SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Justification = "Emphasize variational manner of this item.")]
		public static IEnumerable TestCasesIPSocketSelfs_Text
		{
			get
			{
				foreach (var t in Tests)
				{
					var modifySettings = (bool)(t.Arguments[3]);
					if (modifySettings)
						continue; // No need to generate these settings for IP sockets (yet).

					foreach (var tc in Data.ToIPSocketSelfsTestCases_Text(new TestCaseData[] { t }))
						yield return (tc);
				}
			}
		}

		#endregion
	}

	/// <summary></summary>
	[TestFixture]
	public class SendFileTest
	{
		#region Tests
		//==========================================================================================
		// Tests
		//==========================================================================================

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[Test, TestCaseSource(typeof(SendFileTestTestData), "TestCasesSerialPortLoopbackPairs_Text"), Combinatorial] // Test is mandatory, it shall not be excludable.
		public virtual void TestSerialPortLoopbackPairs(TerminalSettings settingsA, TerminalSettings settingsB, TerminalType terminalType, bool modifySettings, StressFile fileSelection)
		{
			if (!MKY.IO.Ports.Test.ConfigurationProvider.Configuration.LoopbackPairsAreAvailable)
				Assert.Ignore("No serial COM port loopback pairs are available, therefore this test is excluded. Ensure that at least one serial COM port loopback pair is properly configured and available if passing this test is required.");
			//// Using Ignore() instead of Inconclusive() to get a yellow bar, not just a yellow question mark.

			SendAndVerify(settingsA, settingsB, terminalType, modifySettings, fileSelection);
		}

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Selfs", Justification = "Multiple items, same as 'Pairs'.")]
		[Test, TestCaseSource(typeof(SendFileTestTestData), "TestCasesSerialPortLoopbackSelfs_Text")]
		public virtual void TestSerialPortLoopbackSelfs(TerminalSettings settings, TerminalType terminalType, bool modifySettings, StressFile fileSelection)
		{
			if (!MKY.IO.Ports.Test.ConfigurationProvider.Configuration.LoopbackSelfsAreAvailable)
				Assert.Ignore("No serial COM port loopback selfs are available, therefore this test is excluded. Ensure that at least one serial COM port loopback self is properly configured and available if passing this test is required.");
			//// Using Ignore() instead of Inconclusive() to get a yellow bar, not just a yellow question mark.

			SendAndVerify(settings, null, terminalType, modifySettings, fileSelection);
		}

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[Test, TestCaseSource(typeof(SendFileTestTestData), "TestCasesIPSocketPairs_Text")]
		public virtual void TestIPSocketPairs(TerminalSettings settingsA, TerminalSettings settingsB, TerminalType terminalType, bool modifySettings, StressFile fileSelection)
		{
			// IPSocketPairs are always made available by 'Utilities', no need to check for this.

			SendAndVerify(settingsA, settingsB, terminalType, modifySettings, fileSelection);
		}

		/// <remarks>Separation into multiple tests for easier handling and execution.</remarks>
		[SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Selfs", Justification = "Multiple items, same as 'Pairs'.")]
		[Test, TestCaseSource(typeof(SendFileTestTestData), "TestCasesIPSocketSelfs_Text")]
		public virtual void TestIPSocketSelfs(TerminalSettings settings, TerminalType terminalType, bool modifySettings, StressFile fileSelection)
		{
			// IPSocketSelfs are always made available by 'Utilities', no need to check for this.

			SendAndVerify(settings, null, terminalType, modifySettings, fileSelection);
		}

		private static void SendAndVerify(TerminalSettings settingsA, TerminalSettings settingsB, TerminalType terminalType, bool modifySettings, StressFile fileSelection)
		{
			Settings.RevertSettingsIfUdpSocket(settingsA); // Revert to default behavior expected by this test case.
			Settings.RevertSettingsIfUdpSocket(settingsB); // Revert to default behavior expected by this test case.

			var fi = Files.Text.Stress[fileSelection];
			if (fi.LineByteCount > DisplaySettings.MaxLineLengthDefault) // Adjust maximum line length:
			{
				                         settingsA.Display.MaxLineLength = fi.LineByteCount;
				if (settingsB != null) { settingsB.Display.MaxLineLength = fi.LineByteCount; }
			}

			if (modifySettings) // Adjust serial port send settings for sending terminal (always A):
			{
				settingsA.IO.SerialPort.BufferMaxBaudRate = false;
				settingsA.IO.SerialPort.MaxChunkSize = new ChunkSize(false, SerialPortSettings.MaxChunkSizeDefault.Size);

				// Attention, in order to also be able to modify socket or USB settings, test case generation has to be adjusted.
			}

			switch (terminalType)
			{
				case TerminalType.Text:   SendAndVerify_Text(  settingsA, settingsB, fi); break;
				case TerminalType.Binary: SendAndVerify_Binary(settingsA, settingsB, fi); break;

				default: throw (new ArgumentOutOfRangeException("terminalType", terminalType, MessageHelper.InvalidExecutionPreamble + "'" + terminalType + "' is a terminal type that is not (yet) supported!" + System.Environment.NewLine + System.Environment.NewLine + MessageHelper.SubmitBug));
			}
		}

		private static void SendAndVerify_Text(TerminalSettings settingsA, TerminalSettings settingsB, FileInfo fi)
		{
			if (settingsB != null) // Interconnected pair:
				SendAndVerify_Text_Pair(settingsA, settingsB, fi);
			else
				SendAndVerify_Text_Self(settingsA, fi);
		}

		private static void SendAndVerify_Binary(TerminalSettings settingsA, TerminalSettings settingsB, FileInfo fi)
		{
			if (settingsB != null) // Interconnected pair:
				SendAndVerify_Binary_Pair(settingsA, settingsB, fi);
			else
				SendAndVerify_Binary_Self(settingsA, fi);
		}

		private static void SendAndVerify_Text_Pair(TerminalSettings settingsTx, TerminalSettings settingsRx, FileInfo fi)
		{
			using (var terminalTx = new Domain.TextTerminal(settingsTx))
			{
				using (var terminalRx = new Domain.TextTerminal(settingsRx))
				{
					Assert.That(terminalTx.Start(), Is.True, "Terminal Tx could not be started!");
					Assert.That(terminalRx.Start(), Is.True, "Terminal Rx could not be started!");
					Utilities.WaitForConnection(terminalTx, terminalRx);

					SendAndVerify(terminalTx, terminalRx, fi);

					terminalRx.Stop();
					Utilities.WaitForDisconnection(terminalRx);
				}

				terminalTx.Stop();
				Utilities.WaitForDisconnection(terminalTx);
			}
		}

		private static void SendAndVerify_Text_Self(TerminalSettings settingsTxRx, FileInfo fi)
		{
			using (var terminalTxRx = new Domain.TextTerminal(settingsTxRx))
			{
				Assert.That(terminalTxRx.Start(), Is.True, "Terminal Tx/Rx could not be started!");
				Utilities.WaitForConnection(terminalTxRx, terminalTxRx);

				SendAndVerify(terminalTxRx, terminalTxRx, fi);

				terminalTxRx.Stop();
				Utilities.WaitForDisconnection(terminalTxRx);
			}
		}

		private static void SendAndVerify_Binary_Pair(TerminalSettings settingsTx, TerminalSettings settingsRx, FileInfo fi)
		{
			using (var terminalTx = new Domain.BinaryTerminal(settingsTx))
			{
				using (var terminalRx = new Domain.BinaryTerminal(settingsRx))
				{
					Assert.That(terminalTx.Start(), Is.True, "Terminal Tx could not be started!");
					Assert.That(terminalRx.Start(), Is.True, "Terminal Rx could not be started!");
					Utilities.WaitForConnection(terminalTx, terminalRx);

					SendAndVerify(terminalTx, terminalRx, fi);

					terminalRx.Stop();
					Utilities.WaitForDisconnection(terminalRx);
				}

				terminalTx.Stop();
				Utilities.WaitForDisconnection(terminalTx);
			}
		}

		private static void SendAndVerify_Binary_Self(TerminalSettings settingsTxRx, FileInfo fi)
		{
			using (var terminalTxRx = new Domain.BinaryTerminal(settingsTxRx))
			{
				Assert.That(terminalTxRx.Start(), Is.True, "Terminal Tx/Rx could not be started!");
				Utilities.WaitForConnection(terminalTxRx, terminalTxRx);

				SendAndVerify(terminalTxRx, terminalTxRx, fi);

				terminalTxRx.Stop();
				Utilities.WaitForDisconnection(terminalTxRx);
			}
		}

		private static void SendAndVerify(Domain.Terminal terminalTx, Domain.Terminal terminalRx, FileInfo fi)
		{
			terminalTx.SendFile(fi.Path);
			Utilities.WaitForTransmissionAndVerifyCounts(terminalTx, terminalRx, fi.ByteCount, fi.LineCount, fi.Timeout);
		}

		#endregion
	}
}

//==================================================================================================
// End of
// $URL$
//==================================================================================================
